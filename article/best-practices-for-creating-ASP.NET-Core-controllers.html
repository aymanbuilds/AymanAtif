<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best Practices for Creating ASP.NET Core Controllers | Ayman Atif</title>
    <meta name="description"
        content="Learn how to build robust, maintainable, and scalable ASP.NET Core applications following SOLID principles, clean architecture, and modern best practices.">
    <link rel="canonical"
        href="https://aymanbuilds.github.io/AymanAtif/article/best-practices-for-creating-ASP.NET-Core-controllers.html">
    <link rel="icon" href="../assets/icons/favicon.ico" type="image/x-icon">

    <!-- Open Graph -->
    <meta property="og:title" content="Best Practices for Creating ASP.NET Core Controllers | Ayman Atif">
    <meta property="og:description"
        content="Learn how to build robust, maintainable, and scalable ASP.NET Core applications following SOLID principles and clean architecture.">
    <meta property="og:type" content="article">
    <meta property="og:url"
        content="https://aymanbuilds.github.io/AymanAtif/article/best-practices-for-creating-ASP.NET-Core-controllers.html">
    <meta property="og:image"
        content="https://aymanbuilds.github.io/AymanAtif/assets/blog/images/best-practices-for-creating-ASP.NET-Core-controllers.webp">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Raleway:wght@600;700;800&family=Poiret+One&display=swap"
        rel="stylesheet">

    <!-- JSON-LD -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "Best Practices for Creating ASP.NET Core Controllers",
      "image": "https://aymanbuilds.github.io/AymanAtif/assets/blog/images/best-practices-for-creating-ASP.NET-Core-controllers.webp",
      "url": "https://aymanbuilds.github.io/AymanAtif/article/best-practices-for-creating-ASP.NET-Core-controllers.html",
      "datePublished": "2025-11-09",
      "author": {
        "@type": "Person",
        "name": "Ayman Atif"
      },
      "description": "Learn how to build robust, maintainable, and scalable ASP.NET Core applications following SOLID principles, clean architecture, and modern best practices."
    }
    </script>
</head>

<body>

    <!-- HEADER -->
    <header class="header">
        <a class="logo-link" href="../index.html">
            <h1 class="logo">Ayman Atif</h1>
        </a>
        <div class="header-buttons">
            <a target="_blank" href="https://wa.me/+212688459384" class="btn hire-btn"><span data-text="Hire Me">Hire
                    Me</span></a>
            <button id="menu-btn" class="btn menu-btn"><span data-text="Menu">Menu</span></button>

            <!-- FULLSCREEN MENU OVERLAY -->
            <div id="menu-overlay" class="menu-overlay">
                <button id="close-menu" class="close-menu"><i class="fa-solid fa-xmark"></i></button>
                <nav class="overlay-nav">
                    <a href="../index.html">Home</a>
                    <a href="../services.html">Services</a>
                    <a href="../about.html">About</a>
                    <a href="../blog.html">Blog</a>
                </nav>
            </div>
        </div>
    </header>

    <main>
        <!-- Hero / Title -->
        <section class="article-hero" style="background-image: url('../assets/blog/images/best-practices-for-creating-ASP.NET-Core-controllers-cover.webp');
        background-position: bottom;">
            <div class="overlay"></div>
            <div class="hero-content">
                <h1>Best Practices for Creating ASP.NET Core Controllers</h1>
                <p>Learn how to build robust, maintainable, and scalable ASP.NET Core applications following SOLID
                    principles, clean architecture, and modern best practices.</p>
            </div>
        </section>

        <article class="blog-article">
            <!-- Introduction -->
            <section class="article-section">
                <h2>Introduction</h2>
                <p>
                    ASP.NET Core is a modern, high-performance framework for building web APIs and full-stack web
                    applications.
                    Its modular design and built-in features — routing, middleware, dependency injection, configuration,
                    and
                    model binding — make it especially well suited for scalable, testable systems. Well-structured
                    controllers
                    act as thin orchestration layers that translate HTTP requests into business actions while keeping
                    protocol
                    concerns separate from domain logic.
                </p>
                <p>
                    In this article we'll walk through practical ways to structure controllers and surrounding layers so
                    your
                    codebase stays maintainable as it grows. You'll learn which responsibilities belong in controllers
                    versus
                    services or repositories, how to wire dependencies cleanly, and which cross-cutting concerns (like
                    logging,
                    validation, error handling, and authentication) are best handled by middleware or dedicated
                    services. By the
                    end you'll have concrete patterns to write clear, testable controllers that reduce duplication and
                    simplify
                    future changes.
                </p>
            </section>

            <!-- Section: SOLID Principles -->
            <section class="article-section highlight-section">
                <h2>Applying SOLID Principles</h2>
                <p>
                    The SOLID principles form the foundation of maintainable and extensible software design.
                    When applied to ASP.NET Core controllers, they help prevent tightly coupled logic,
                    make testing easier, and promote cleaner architecture. Controllers should act as
                    simple entry points that coordinate data flow between the client and the business layers,
                    not as containers for business rules or database logic.
                </p>
                <ul>
                    <li><strong>S — Single Responsibility:</strong> Each controller should have only one clear
                        responsibility.
                        For example, a <code>ProductsController</code> should only manage product-related actions,
                        leaving validation or business processing to services.</li>
                    <li><strong>O — Open/Closed:</strong> Controllers should be open for extension but closed for
                        modification.
                        If you need new behavior, inject a new service or extend functionality without rewriting
                        existing controller logic.</li>
                    <li><strong>L — Liskov Substitution:</strong> You should be able to replace any service or
                        repository implementation
                        with another one that follows the same abstraction without breaking the controller’s
                        functionality.
                        This makes refactoring or switching data sources easier.</li>
                    <li><strong>I — Interface Segregation:</strong> Design small, focused interfaces for your services
                        and repositories.
                        Controllers should depend only on what they actually need — not large, general-purpose
                        interfaces.</li>
                    <li><strong>D — Dependency Inversion:</strong> Always depend on abstractions (interfaces), not
                        concrete implementations.
                        This keeps your controller decoupled from lower-level modules and allows flexible swapping of
                        dependencies through DI.</li>
                </ul>
                <p>
                    By following SOLID principles, controllers remain lean and maintainable.
                    Each layer in your application — from controllers to repositories — becomes easier to test,
                    reuse, and refactor independently. This separation of concerns ensures that as your project grows,
                    complexity stays manageable and your architecture remains adaptable to future changes.
                </p>
            </section>

            <!-- Section: Layered Architecture -->
            <section class="article-section">
                <h2>Repository & Service Layer</h2>
                <p>
                    To achieve clean separation of concerns, it’s essential to divide your application into distinct
                    layers.
                    In ASP.NET Core, the <strong>Repository layer</strong> handles all database operations, while the
                    <strong>Service layer</strong> contains the business logic that defines how data should be processed
                    or validated
                    before it reaches the controller or persistence layer.
                </p>
                <p>
                    This design ensures that controllers remain lightweight and focused on handling HTTP requests and
                    responses.
                    Services manage rules, transformations, and business flows, while repositories deal only with data
                    persistence.
                    By isolating these responsibilities, you make your codebase easier to test, maintain, and scale —
                    and you can
                    change your data source (for example, switching from SQL to NoSQL) without affecting your business
                    or presentation logic.
                </p>

                <pre><code class="language-csharp">
// Repository Interface
public interface IProductRepository
{
    Task<IEnumerable<Product>> GetAllAsync();
    Task<Product?> GetByIdAsync(int id);
    Task AddAsync(Product product);
    Task UpdateAsync(Product product);
    Task DeleteAsync(int id);
}

// Repository Implementation
public class ProductRepository : IProductRepository
{
    private readonly AppDbContext _context;

    public ProductRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<Product>> GetAllAsync() =>
        await _context.Products.ToListAsync();

    public async Task<Product?> GetByIdAsync(int id) =>
        await _context.Products.FindAsync(id);

    public async Task AddAsync(Product product)
    {
        _context.Products.Add(product);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(Product product)
    {
        _context.Products.Update(product);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(int id)
    {
        var product = await GetByIdAsync(id);
        if (product != null)
        {
            _context.Products.Remove(product);
            await _context.SaveChangesAsync();
        }
    }
}

// Service Interface
public interface IProductService
{
    Task<IEnumerable<Product>> GetProductsAsync();
    Task<Product?> GetProductByIdAsync(int id);
    Task AddProductAsync(Product product);
}

// Service Implementation
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;

    public ProductService(IProductRepository repository)
    {
        _repository = repository;
    }

    public async Task<IEnumerable<Product>> GetProductsAsync() =>
        await _repository.GetAllAsync();

    public async Task<Product?> GetProductByIdAsync(int id) =>
        await _repository.GetByIdAsync(id);

    public async Task AddProductAsync(Product product)
    {
        // Example business rule: prevent duplicate product names
        var existing = (await _repository.GetAllAsync())
                        .FirstOrDefault(p => p.Name == product.Name);
        if (existing != null)
            throw new InvalidOperationException("A product with this name already exists.");

        await _repository.AddAsync(product);
    }
}
    </code></pre>

                <p>
                    In this example, the repository deals only with Entity Framework Core operations,
                    while the service enforces a business rule before inserting data. The controller will
                    call the service methods instead of directly accessing the database, ensuring that all
                    requests pass through a consistent layer of logic and validation.
                </p>
            </section>

            <section class="article-section highlight-section">
                <h2>Dependency Injection</h2>
                <p>
                    Dependency Injection (DI) is a core feature of ASP.NET Core that promotes loose coupling between
                    classes.
                    Instead of having controllers or services create their dependencies directly, the framework’s
                    built-in
                    IoC (Inversion of Control) container provides them at runtime. This improves testability,
                    flexibility,
                    and maintainability — allowing you to swap implementations without changing your controller code.
                </p>
                <p>
                    By registering your repositories and services in the DI container, ASP.NET Core automatically
                    resolves
                    dependencies through constructor injection. This makes your code cleaner and easier to manage,
                    especially in larger projects with multiple layers and modules.
                </p>

                <pre><code class="language-csharp">
// Program.cs (or Startup.cs in older versions)

// Register dependencies
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<IProductService, ProductService>();

// Add other framework services
builder.Services.AddControllers();
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();
    </code></pre>

                <p>
                    Once registered, dependencies can be injected directly into your controllers.
                    This keeps controllers lightweight, allowing them to delegate logic to services rather than
                    performing
                    data operations or business calculations themselves.
                </p>

                <pre><code class="language-csharp">
// Example Controller using Dependency Injection

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;

    public ProductsController(IProductService productService)
    {
        _productService = productService;
    }

    [HttpGet]
    public async Task<IActionResult> GetAllProducts()
    {
        var products = await _productService.GetProductsAsync();
        return Ok(products);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetProduct(int id)
    {
        var product = await _productService.GetProductByIdAsync(id);
        if (product == null)
            return NotFound();

        return Ok(product);
    }

    [HttpPost]
    public async Task<IActionResult> AddProduct(Product product)
    {
        await _productService.AddProductAsync(product);
        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);
    }
}
    </code></pre>

                <p>
                    Here, the controller depends only on the <code>IProductService</code> abstraction.
                    The actual <code>ProductService</code> implementation is injected automatically by the DI container.
                    This approach ensures a clean separation of concerns and allows you to easily replace or mock
                    services
                    for unit testing without altering controller logic.
                </p>
            </section>

            <!-- Section: Middleware & JWT -->
            <section class="article-section highlight-section">
                <h2>Database Optimization</h2>
                <p>
                    As your ASP.NET Core application grows, database performance becomes a key factor in overall
                    responsiveness
                    and scalability. Even well-structured code can become slow if queries are inefficient or the
                    database is
                    overloaded. Optimizing database access involves using asynchronous calls, efficient queries,
                    caching, and
                    indexing — all while maintaining data consistency.
                </p>
                <p>
                    The <strong>Repository layer</strong> is the ideal place to apply optimization strategies. Since it
                    centralizes
                    data access, you can improve performance without affecting the rest of your application’s logic.
                    Below are
                    several best practices for keeping database interactions efficient and scalable.
                </p>

                <ul>
                    <li><strong>Use Asynchronous Queries:</strong> Always use <code>async</code> and <code>await</code>
                        when interacting
                        with the database to avoid blocking threads in high-traffic applications.</li>
                    <li><strong>Use Projection with Select:</strong> Retrieve only the fields you need using
                        <code>Select()</code> to
                        reduce memory overhead.
                    </li>
                    <li><strong>Apply Caching:</strong> Cache frequently requested data to minimize redundant database
                        calls.</li>
                    <li><strong>Include Related Data Wisely:</strong> Use <code>Include()</code> in Entity Framework
                        only when necessary
                        to prevent loading large object graphs unintentionally.</li>
                    <li><strong>Paginate Large Results:</strong> Implement pagination to limit the amount of data
                        returned in each request.</li>
                    <li><strong>Index Frequently Queried Columns:</strong> Ensure that key columns used in filtering or
                        sorting are properly indexed.</li>
                </ul>

                <pre><code class="language-csharp">
// Example: Optimized Repository Query

public class ProductRepository : IProductRepository
{
    private readonly AppDbContext _context;

    public ProductRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<ProductDto>> GetPagedProductsAsync(int page, int pageSize)
    {
        return await _context.Products
            .AsNoTracking() // avoids tracking overhead for read-only queries
            .OrderBy(p => p.Name)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Select(p => new ProductDto
            {
                Id = p.Id,
                Name = p.Name,
                Price = p.Price,
                Category = p.Category.Name
            })
            .ToListAsync();
    }
}
    </code></pre>

                <p>
                    In the example above, the query is fully asynchronous, uses <code>AsNoTracking()</code> for
                    read-only operations,
                    and returns lightweight DTOs instead of full entities. This significantly reduces query time and
                    memory usage,
                    especially when handling thousands of records.
                </p>

                <pre><code class="language-csharp">
// Example: Applying Caching in the Service Layer

public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly IMemoryCache _cache;

    public ProductService(IProductRepository repository, IMemoryCache cache)
    {
        _repository = repository;
        _cache = cache;
    }

    public async Task<IEnumerable<ProductDto>> GetCachedProductsAsync(int page, int pageSize)
    {
        string cacheKey = $"products_page_{page}_{pageSize}";

        if (!_cache.TryGetValue(cacheKey, out IEnumerable<ProductDto>? products))
        {
            products = await _repository.GetPagedProductsAsync(page, pageSize);

            // Cache results for 1 minute
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1)
            };
            _cache.Set(cacheKey, products, cacheOptions);
        }

        return products!;
    }
}
    </code></pre>

                <p>
                    By introducing caching and pagination, your application reduces unnecessary database load and
                    improves
                    response times for frequently accessed data. Combining efficient queries with proper caching
                    strategies
                    results in an API that remains fast, even under heavy traffic.
                </p>
            </section>

            <!-- Conclusion -->
            <section class="article-section highlight-section">
                <h2>Conclusion</h2>
                <p>
                    Building scalable and maintainable ASP.NET Core applications requires more than just writing
                    functional code —
                    it’s about designing with clarity, structure, and long-term growth in mind. By following the
                    principles and
                    practices discussed in this article, you can ensure that every part of your application serves a
                    distinct purpose
                    and remains easy to extend or modify.
                </p>
                <p>
                    The <strong>SOLID principles</strong> guide you in writing clean, modular code. Implementing a clear
                    <strong>Repository</strong> and <strong>Service Layer</strong> architecture keeps business logic
                    separate from
                    data access and presentation. Through <strong>Dependency Injection</strong>, your components become
                    loosely coupled
                    and easily testable, while <strong>Middleware</strong> centralizes cross-cutting concerns like
                    logging, authentication,
                    and error handling.
                </p>
                <p>
                    Finally, <strong>Database Optimization</strong> ensures your application remains performant and
                    efficient as it scales.
                    Combining techniques like asynchronous queries, caching, and pagination allows you to handle large
                    datasets without
                    sacrificing speed or reliability.
                </p>
                <p>
                    Altogether, these best practices form the foundation of a clean and professional ASP.NET Core API
                    architecture.
                    With proper structure, your codebase becomes not only easier to maintain but also more resilient to
                    future
                    changes — empowering you to focus on innovation rather than maintenance.
                </p>
            </section>
        </article>

        <section id="explore-articles" class="posts-section" style="text-align: center;">
            <div class="container">
                <h2 class="section-title">Explore Other Articles</h2>
                <p class="section-desc">
                    Dive into more tutorials, insights, and tips on web, desktop, and mobile development.
                </p>

                <!-- Posts Grid -->
                <div class="posts-grid">
                    <div class="post-card" data-link="../article/mastering-seo-on-page-and-off-page-strategies.html"
                        data-category="SEO">
                        <img src="../assets/blog/images/seo-strategies.webp" alt="SEO best practices illustration">
                        <h3>Mastering SEO: On-Page and Off-Page Strategies</h3>
                        <p>Discover the key techniques for boosting your website’s visibility with effective on-page
                            optimization and powerful off-page SEO tactics that drive long-term growth.</p>
                    </div>

                    <div class="post-card" data-link="../article/whats-new-in-csharp-10.html"
                        data-category="Desktop Development">
                        <img src="../assets/blog/images/csharp10-features.webp" alt="C# 10 new features illustration">
                        <h3>What’s New in C# 10: Features and Improvements</h3>
                        <p>Explore the latest enhancements in C# 10, including global using directives, file-scoped
                            namespaces, record improvements, and other modern features that simplify coding and improve
                            maintainability.</p>
                    </div>

                    <div class="post-card" data-link="../article/java-vs-kotlin-for-android-development.html"
                        data-category="Mobile Development">
                        <img src="../assets/blog/images/java-vs-kotlin.webp"
                            alt="Java vs Kotlin comparison for Android development">
                        <h3>Java vs Kotlin: Choosing the Best Language for Android Development</h3>
                        <p>Compare Java and Kotlin for Android development, explore their pros and cons, and learn which
                            language is best suited for modern Android apps.</p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- FOOTER -->
    <footer class="site-footer">
        <nav class="footer-nav">
            <a href="../index.html">Home</a>
            <a href="../services.html">Services</a>
            <a href="../about.html">About</a>
            <a href="../blog.html">Blog</a>
        </nav>
        <p class="footer-copy">&copy; 2025 Ayman Atif. All rights reserved.</p>
    </footer>

    <script>
        const menuBtn = document.getElementById('menu-btn');
        const closeMenu = document.getElementById('close-menu');
        const menuOverlay = document.getElementById('menu-overlay');

        menuBtn.addEventListener('click', () => {
            menuOverlay.classList.add('active');
        });

        closeMenu.addEventListener('click', () => {
            menuOverlay.classList.remove('active');
        });

        // Optional: Close menu when clicking outside the nav
        menuOverlay.addEventListener('click', (e) => {
            if (e.target === menuOverlay) {
                menuOverlay.classList.remove('active');
            }
        });

        document.querySelectorAll('.post-card').forEach(card => {
            card.addEventListener('click', () => {
                const link = card.dataset.link;
                if (link) window.location.href = link;
            });
        });
    </script>
</body>

</html>